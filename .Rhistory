#' output: pdf_document
#' toc: true
#' highlight: zenburn
#' bibliography: ./references.bib
#' ---
#'
#' # Preface
#' 
#' This code is tested using a raw R terminal. Path names are 
#' defined relative to the project directory. This code commentary is included 
#' in the R code itself and can be rendered at any stage using 
#' `rmarkdown::render ("./50_eda.R")`. Please check the 
#' session info at the end of the document for further notes on the coding environment.
#' 
#' This code explores does something.
#'
#' # Prerequisites
#' 
#' * Data was pre-processed in Shell and R pipeline as outlined in the documentation 
#'   for `pcm_modeling` and in this repository.
#' * This script is located in the project parent directory.
#' * Scripts `10_import_predictors.R`, `20_format_predictors.R` and 
#'   `30_format_phyloseq.R` were run. 
#' * OR: the objects to be read in are available in a folder tree `Zenodo` in the 
#'   project parent directory.
#' * `00_functions.R` is available in the project directory
#' 
#' <!-- #################################################################### -->
#' <!-- #################################################################### -->
#' 
#' # Environment preparation
#'
#' ## Package loading and cleaning of work-space
#+ message=FALSE, results='hide'
library ("phyloseq")  # required for working with phyloseq objects
library ("ggbiplot")  # package for simple generation of PCA biplots
library ("ggplot2")   # package used for barplot (for themes()) 
library ("corrplot")  # plotting of correlations
library ("gridExtra") # re-arranging graphical objects 
library ("GGally")    # scatter plot matrices (geochemical and combined data)
library ("vegan")     # CCA and MDS
library ("dplyr")     # for easier reading of complex expressions
rm(list=ls())         # clear R environment
                      # working directory is current directory by default 
                      #   and needs not to be set
#' ## Setting locations for data import and export
#' 
#' This script uses the objects generated by `40_merging.R` that are located
#' in the `Zenodo` directory tree. It will also write to that location. The 
#' number in front of the file name denotes the source script.
# import locations
path_phsq_ob_comb <- "./Zenodo/R_Objects/30_phsq_ob_comb.Rdata"
                                                      # combined object
                                                      # with sample data
# output locations
path_workspace    <- "./Zenodo/R_Objects/50_workspace.Rdata"
#' <!-- #################################################################### -->
#' <!-- #################################################################### -->
#' ## Loading functions
#'
#' This script uses many functions, and it impractical  to have them all in here.
#' They are loaded from `00_functions.R`.
source ("00_functions.R")
#' <!-- #################################################################### -->
#' <!-- #################################################################### -->
#' # Data object import
#' 
#' Phylotype data is imported using basic R functionality. Imported are phyloseq
#' objects [@McMurdie2013].
load (path_phsq_ob_comb) # object name is "phsq_ob_comb"
#' ## Defining predictor categories
#' 
#' These character vectors can be passed to `get_predictors()` to create data 
#' frames with customised variable content.
geochems <- c ("AMMN", "NITR", "POTA", "SLPH", "COND", "PHCC",  "PHOS", "CARB",
               "PHHO")
                        # "AMMN" and "NITR" with 57% and 47% undefined data
                        #   may be removed, these may hold important 
                        #   information. "PHOS" "CARB" may be removed because not 
                        #   relevant for MM?
minerals <- c ("QUTZ", "FDSP", "TTAN", "PRAG", "MICA", "DOLO", "KAOC")  
                        # "CALC" with 33 NA's and "CHLR" with 52 NA's
                        #   are removed, otherwise the MM mineral composition
                        #   can't be analysed 
location <- c ("AREA")
position <- c ("LONG", "LATI")
                        # for spatial distance matrices
raw_ages <- c ("LAGE", "HAGE")
                        # low and high age estimate
#' <!-- #################################################################### -->
#' <!-- #################################################################### -->
#' # Check imported `phyloseq` object 
#' 
#' The following plots are agglomerated on a specified level in the plotting
#' function. By doing so, "1"s are added up to the indicated rank. In the first
#' plot this effect is visible, and gives an idea of the taxonomic detail of the
#'  data. In the second plot, all added-up values are re-set to one, and the rank
#' level compositions is better visible. This is for diagnostic purposes only, 
#' to check if the imported objects are ok.
check1 <- barplot_samples (phsq_ob, "Class")
check2 <- barplot_samples (make_binary (agglomerate (phsq_ob, "Class")), "Class")
#+ message=FALSE, results='hide', warning=FALSE, fig.width=10, fig.height=10, dpi=200, fig.align='center',  fig.cap="Taxonomic composition at selected taxonomic level, with cumulatitive sum scaling. (approx. code line 559)"
grid.arrange(check1, check2, nrow = 2)
rm(check1, check2)
#' <!-- #################################################################### -->
#' <!-- #################################################################### -->
#' Saving of temporary work space during coding, so that, code above doesn't
#' have to be run all the time, when changing the tiniest bit downstream.
save.image (path_workspace)                    
#' <!-- #################################################################### -->
#' <!-- #################################################################### -->
#' # Exploratory data analysis
#'
#' ##  Isolating data for this analysis 
#' 
#' Starting, again by getting the data frames. For now, unless `get_list()`
#' is modified, a lot is crammed into vector `pred_cat` which will be returned
#' in `obs`. Can't include `raw_ages` here, since it's rich in `NA`s and these
#' are filtered by `get_list()`.
matr_ana <- get_list (phsq_ob, tax_rank = "Class", pred_cat = c (geochems, 
  minerals, position))
#' Returned as `data.frames` in list are `spc`, `obs`, `grp`, and `gen`.
grp <- matr_ana[["grp"]] # for PCA labels
spc <- matr_ana[["spc"]] # species data
#' `obs` is a mixture of things, which need to be treated separately in the
#' following. Hence some isolation work is necessary. The objects are erased from
#' the input list, as a precaution. ** There is a semicolon here!** Afterwards
#' `matr_ana[["obs"]]` is empty. 
posi <- matr_ana[["obs"]] [ , position]; matr_ana[["obs"]] [ , position] <- NULL  
chem <- matr_ana[["obs"]] [ , geochems]; matr_ana[["obs"]] [ , geochems] <- NULL  
minl <- matr_ana[["obs"]] [ , minerals]; matr_ana[["obs"]] [ , minerals] <- NULL
#' <!-- #################################################################### -->
#' <!-- #################################################################### -->
#' 
#' ##  Checking soil mineral and soil geochemical data
#'
#' ### Showing the initial state of the mineral and chemical data
#'
#' Isolated and combined mineral and chemical data from the `phyloseq` object,
#' congruent with rows in `spc`, `grp`, and `gen`.
#+ message=FALSE, results='hide', warning=FALSE, fig.width=12, fig.height=12, dpi=200, fig.align='center', fig.cap="Isolated and combined mineral and chemical data, unmodified. (approx. code line 165)"
ggpairs ( data.frame (chem, minl, check.rows = TRUE))
summary ( data.frame (chem, minl, check.rows = TRUE))
str (data.frame (chem, minl, check.rows = TRUE))
# violin plots for unmodified chemical data
#+ message=FALSE, results='hide', warning=FALSE, fig.width=12, fig.height=12, dpi=200, fig.align='center', fig.cap="Chemical data per location, unmodified. (approx. code line 174)"
add_discretex (chem, grp, dfr_x_name = "AREA") %>% 
 get_violinplotlist ( . ,"AREA") %>%
 marrangeGrob ( . , nrow=3, ncol=3)
 
# violin plots for unmodified mineral data
#+ message=FALSE, results='hide', warning=FALSE, fig.width=12, fig.height=12, dpi=200, fig.align='center', fig.cap="Mineral data per location, unmodified. (approx. code line 174)"
add_discretex (minl, grp, dfr_x_name = "AREA") %>% 
 get_violinplotlist ( . ,"AREA") %>%
 marrangeGrob ( . , nrow=3, ncol=3)
#' ###  Removing outliers in soil geochemical observations
#'
#' Many ordination approaches are sensitive to outliers, and perhaps this also
#' affects modelling approaches. Outliers are removed here and replaced with the
#' mean. If desired this could perhaps be left out at later stages. This is not
#' done for the rank / compositional mineral data, but only the soil geochemical
#' values.
chem <- remove_outliers (chem) 
#' ###  Transformations  
#'
#' These are helpful for all modelling attempts, PCA, and ANOVA approaches. 
#' 
#' Centred log ration transform for the mineral data as recommended by [@Ranganathan2011],
#' in order to use this data for PCA and alongside the chemical data. The 
#' transformation will remove rows from the data farame.
minl  <- data.frame (transform_clr (minl))
#' Yeo-Johnson transformation conducted here after recombining the data frame
#' (and garbage collection). 
# merging of data frame and garbage collection 
obs <- merge(chem, minl, by = "row.names", all = TRUE); rownames (obs) <- 
  obs$Row.names; obs$Row.names <- NULL ; rm (chem); rm(minl)
# transformation of combined mineral an chemical data 
obs <- transform_any (obs, method = c ("center", "scale", "YeoJohnson", "nzv")) 
obs <- obs[complete.cases(obs), ]
#' ### Plotting co-correlations
#'
#' A simple function call to see precisely, which variables are co-correlated.
#+ message=FALSE, results='hide', warning=FALSE, fig.width=12, fig.height=8, dpi=200, fig.align='center', fig.cap="removal of co-correlations un-transformed chemical data. (approx. code line 610)"
par (mfrow = c (1, 2))
get_corrplots(obs, remove_cocorrelated(obs))
#' ###  Removing the co-correlated variables 
#' 
#' In addition to the plot above, the text confirms which 
#' variables are kept, and which ones are removed. 
obs <- remove_cocorrelated(obs)
#' ### Plotting out transformed mineral and chemical data
#'
#' Plot the data before it goes to into further analyses, only for checking.
#' Initially a scatterplot.
#+ message=FALSE, results='hide', warning=FALSE, fig.width=12, fig.height=12, dpi=200, fig.align='center', fig.cap="Scatterplot of centred and scaled mineral and chemical data (approx. code line 231)."
ggpairs(obs) # less co-correlation, less skew?
summary (obs)
#' And the violin plots.
#+ message=FALSE, results='hide', warning=FALSE, fig.width=12, fig.height=12, dpi=200, fig.align='center', fig.cap="Violin plot of scaled mineral and chemical data. Note that several samples have been excluded when merging mineral and chemical data (approx. code line 235)."
add_discretex (obs, grp, dfr_x_name = "AREA") %>% 
 get_violinplotlist ( . ,"AREA") %>%
 marrangeGrob ( . , nrow=5, ncol=3)
#' <!-- #################################################################### -->
#' <!-- #################################################################### -->
#' 
#' ##  Checking species information 
#'
#' ### Showing the initial state of the species information 
#' 
#' Here used is the initial abundance data, which is abundance corrected using 
#' the CSS algorithm in Qiime [@Paulson2013] _"With CSS, raw counts are divided 
#' by the cumulative sum of counts up to a percentile determined using a data-driven 
#' approach."_
#" The data is shown using a scatterplot
#' and a violin plot. 
#+ message=FALSE, results='hide', warning=FALSE, fig.width=12, fig.height=12, dpi=200, fig.align='center', fig.cap="Scatter plot of cumulative sum-scaled species observations (approx. code line 256)."
ggpairs (spc)
summary (spc) 
#+ message=FALSE, results='hide', warning=FALSE, fig.width=12, fig.height=12, dpi=200, fig.align='center', fig.cap="Violin plot of cumulative sum-scaled species observations (approx. code line 259)."
add_discretex ( as.data.frame(spc), grp, dfr_x_name = "AREA") %>% 
 get_violinplotlist ( . ,"AREA") %>%
 marrangeGrob ( . , nrow=3, ncol=2)
#' <!-- #################################################################### -->
spc <- cmpl_phylotypes(spc, obs)
spc <- cmpl_phylotypes(spc, obs)
#' ## Getting a `metaMDS` object from the species data
#' 
#' Calculating a `metaMDS` object on the `spc` data, for now without environmental
#' variables. Distance `jaccard` appears to be recommended in `vegan()`, 
#' `binary = TRUE` ensures correct distance calculation on presence / absence 
#' data. `try` is set higher, to look longer for solutions. Stress > 0.05 provides
#' an excellent representation in reduced dimensions, > 0.1 is great, > 0.2 is 
#' fair, and stress > 0.3 provides a poor representation. Inspect the generated 
#' model in the end. 
spc_mds <- metaMDS(spc, distance = "euclidean" ,  k = 2, try = 500, trymax = 1000, 
  noshare = FALSE, wascores = TRUE, trace = 0, plot = FALSE, expand = TRUE, 
  binary = FALSE)
spc_mds # stress value is 0.07224375
plot(spc_mds)
env <- envfit(spc_mds, obs, permutations = 5000)
env
par (mfrow = c (1, 1))
ordiplot (spc_mds, display = "sites", type = "p")
ordiellipse(spc_mds,grp, display = "sites", kind = "se", conf = 0.95, label = T, 
  col = c ("coral3", "chartreuse4", "cornflowerblue"))
grp
par (mfrow = c (1, 1))
ordiplot (spc_mds, display = "sites", type = "p")
ordiellipse(spc_mds, shorten_groups (grp, obs) , display = "sites", kind = "se", conf = 0.95, label = T, 
par (mfrow = c (1, 1))
ordiplot (spc_mds, display = "sites", type = "p")
ordiellipse(spc_mds, shorten_groups (grp, obs) , display = "sites", kind = "se", conf = 0.95, label = T, 
  col = c ("coral3", "chartreuse4", "cornflowerblue"))
orditorp (spc_mds, display = "species", col="red", air = 0.01, cex = 1.0)
with (obs, ordisurf (spc_mds, SLPH, add = TRUE, col = "red" ))
with (obs, ordisurf (spc_mds, FDSP, add = TRUE, col = "green" ))
env <- envfit(spc_mds, obs, permutations = 5000)
env
par (mfrow = c (1, 1))
ordiplot (spc_mds, display = "sites", type = "p")
ordihull (spc.mds, groups  = shorten_groups (grp, obs) , 
  col = c ("coral3", "chartreuse4", "cornflowerblue") )
# ordiellipse(spc_mds, shorten_groups (grp, obs) , display = "sites", kind = "se", conf = 0.95, label = T, 
#  col = c ("coral3", "chartreuse4", "cornflowerblue"))
orditorp (spc_mds, display = "species", col="red", air = 0.01, cex = 1.0)
with (obs, ordisurf (spc_mds, SLPH, add = TRUE, col = "red" ))
with (obs, ordisurf (spc_mds, FDSP, add = TRUE, col = "green"))
ordiplot (spc_mds, display = "sites", type = "p")
ordihull (spc.mds, groups  = shorten_groups (grp, obs) , 
  col = c ("coral3", "chartreuse4", "cornflowerblue") )
ordihull (spc_mds, groups  = shorten_groups (grp, obs) , 
  col = c ("coral3", "chartreuse4", "cornflowerblue") )
ordiellipse(spc_mds, shorten_groups (grp, obs) , display = "sites", kind = "se", conf = 0.95, label = T, 
  col = c ("coral3", "chartreuse4", "cornflowerblue"))
orditorp (spc_mds, display = "species", col="red", air = 0.01, cex = 1.0)
with (obs, ordisurf (spc_mds, SLPH, add = TRUE, col = "red" ))
with (obs, ordisurf (spc_mds, FDSP, add = TRUE, col = "green"))
ordiplot (spc_mds, display = "sites", type = "t")
?ordiplot()
shorten_groups (grp, obs)
par (mfrow = c (1, 1))
ordiplot (spc_mds, display = "sites", labels = shorten_groups (grp, obs) )
?ordiplot()
par (mfrow = c (1, 1))
ordiplot (spc_mds, display = "sites" )
par (mfrow = c (1, 1))
ordiplot (spc_mds, display = "sites" )
# ordihull (spc_mds, groups  = shorten_groups (grp, obs) , 
#   col = c ("coral3", "chartreuse4", "cornflowerblue") )
ordiellipse(spc_mds, shorten_groups (grp, obs) , display = "sites", kind = "se", conf = 0.95, label = T, 
  col = c ("coral3", "chartreuse4", "cornflowerblue"))
orditorp (spc_mds, display = "species", col="red", air = 0.01, cex = 1.0)
with (obs, ordisurf (spc_mds, SLPH, add = TRUE, col = "red" ))
with (obs, ordisurf (spc_mds, FDSP, add = TRUE, col = "green"))
env <- envfit(spc_mds, obs, permutations = 5000)
env
par (mfrow = c (1, 1))
ordiplot (spc_mds, display = "sites" )
ordihull (spc_mds, groups  = shorten_groups (grp, obs) , 
   col = c ("coral3", "chartreuse4", "cornflowerblue") )
# ordiellipse(spc_mds, shorten_groups (grp, obs) , display = "sites", kind = "se", conf = 0.95, label = T, 
#   col = c ("coral3", "chartreuse4", "cornflowerblue"))
orditorp (spc_mds, display = "species", col="red", air = 0.01, cex = 1.0)
with (obs, ordisurf (spc_mds, SLPH, add = TRUE, col = "red" ))
with (obs, ordisurf (spc_mds, FDSP, add = TRUE, col = "green"))
#' ## Getting a `metaMDS` object from the species data
#' 
#' Calculating a `metaMDS` object on the `spc` data, for now without environmental
#' variables. Distance `jaccard` appears to be recommended in `vegan()`, 
#' `binary = TRUE` ensures correct distance calculation on presence / absence 
#' data. `try` is set higher, to look longer for solutions. Stress > 0.05 provides
#' an excellent representation in reduced dimensions, > 0.1 is great, > 0.2 is 
#' fair, and stress > 0.3 provides a poor representation. Inspect the generated 
#' model in the end. 
spc_mds <- metaMDS(spc, distance = "jaccard" ,  k = 2, try = 500, trymax = 1000, 
  noshare = FALSE, wascores = TRUE, trace = 0, plot = FALSE, expand = TRUE, 
  binary = FALSE)
spc_mds # stress value is 0.07224375
#' ### Fitting environmental vectors 
#' 
env <- envfit(spc_mds, obs, permutations = 5000)
env
par (mfrow = c (1, 1))
ordiplot (spc_mds, display = "sites" )
ordihull (spc_mds, groups  = shorten_groups (grp, obs) , 
   col = c ("coral3", "chartreuse4", "cornflowerblue") )
# ordiellipse(spc_mds, shorten_groups (grp, obs) , display = "sites", kind = "se", conf = 0.95, label = T, 
#   col = c ("coral3", "chartreuse4", "cornflowerblue"))
orditorp (spc_mds, display = "species", col="red", air = 0.01, cex = 1.0)
with (obs, ordisurf (spc_mds, SLPH, add = TRUE, col = "red" ))
with (obs, ordisurf (spc_mds, FDSP, add = TRUE, col = "green"))
spc_mds <- metaMDS(spc, distance = "bray" ,  k = 2, try = 500, trymax = 1000, 
  noshare = FALSE, wascores = TRUE, trace = 0, plot = FALSE, expand = TRUE, 
  binary = FALSE)
spc_mds # stress value is 0.07224375
#' ### Fitting environmental vectors 
#' 
env <- envfit(spc_mds, obs, permutations = 5000)
env
par (mfrow = c (1, 1))
ordiplot (spc_mds, display = "sites" )
ordihull (spc_mds, groups  = shorten_groups (grp, obs) , 
   col = c ("coral3", "chartreuse4", "cornflowerblue") )
# ordiellipse(spc_mds, shorten_groups (grp, obs) , display = "sites", kind = "se", conf = 0.95, label = T, 
#   col = c ("coral3", "chartreuse4", "cornflowerblue"))
orditorp (spc_mds, display = "species", col="red", air = 0.01, cex = 1.0)
with (obs, ordisurf (spc_mds, SLPH, add = TRUE, col = "red" ))
with (obs, ordisurf (spc_mds, FDSP, add = TRUE, col = "green"))
spc_mds <- metaMDS(spc, distance = "eculid" ,  k = 2, try = 500, trymax = 1000, 
  noshare = FALSE, wascores = TRUE, trace = 0, plot = FALSE, expand = TRUE, 
  binary = FALSE)
spc_mds # stress value is 0.07224375
#' ### Fitting environmental vectors 
#' 
env <- envfit(spc_mds, obs, permutations = 5000)
env
par (mfrow = c (1, 1))
ordiplot (spc_mds, display = "sites" )
ordihull (spc_mds, groups  = shorten_groups (grp, obs) , 
   col = c ("coral3", "chartreuse4", "cornflowerblue") )
# ordiellipse(spc_mds, shorten_groups (grp, obs) , display = "sites", kind = "se", conf = 0.95, label = T, 
#   col = c ("coral3", "chartreuse4", "cornflowerblue"))
orditorp (spc_mds, display = "species", col="red", air = 0.01, cex = 1.0)
with (obs, ordisurf (spc_mds, SLPH, add = TRUE, col = "red" ))
with (obs, ordisurf (spc_mds, FDSP, add = TRUE, col = "green"))
par (mfrow = c (1, 1))
ordiplot (spc_mds, display = "sites" )
ordihull (spc_mds, groups  = shorten_groups (grp, obs) , 
   col = c ("coral3", "chartreuse4", "cornflowerblue") )
# ordiellipse(spc_mds, shorten_groups (grp, obs) , display = "sites", kind = "se", conf = 0.95, label = T, 
#   col = c ("coral3", "chartreuse4", "cornflowerblue"))
orditorp (spc_mds, display = "species", col="red", air = 0.01, cex = 1.0)
with (obs, ordisurf (spc_mds, SLPH, add = TRUE, col = "red" ))
with (obs, ordisurf (spc_mds, FDSP, add = TRUE, col = "green"))
#' ## Matching up phylotype and factor information. 
#'
#' Species observations have to match the observations.
spc <- cmpl_phylotypes(spc, obs)
#' ## Getting a `metaMDS` object from the species data
#' 
#' Calculating a `metaMDS` object on the `spc` data, for now without environmental
#' variables. Distance `jaccard` appears to be recommended in `vegan()`, 
#' `binary = TRUE` ensures correct distance calculation on presence / absence 
#' data. `try` is set higher, to look longer for solutions. Stress > 0.05 provides
#' an excellent representation in reduced dimensions, > 0.1 is great, > 0.2 is 
#' fair, and stress > 0.3 provides a poor representation. Inspect the generated 
#' model in the end. 
spc_mds <- metaMDS(spc, distance = "euclid" ,  k = 2, try = 500, trymax = 1000, 
  noshare = FALSE, wascores = TRUE, trace = 0, plot = FALSE, expand = TRUE, 
  binary = FALSE)
spc_mds # stress value is 0.07224375
#' ### Fitting environmental vectors 
#' 
env <- envfit(spc_mds, obs, permutations = 5000)
env
par (mfrow = c (1, 1))
ordiplot (spc_mds, display = "sites" )
ordihull (spc_mds, groups  = shorten_groups (grp, obs) , 
   col = c ("coral3", "chartreuse4", "cornflowerblue") )
# ordiellipse(spc_mds, shorten_groups (grp, obs) , display = "sites", kind = "se", conf = 0.95, label = T, 
#   col = c ("coral3", "chartreuse4", "cornflowerblue"))
orditorp (spc_mds, display = "species", col="red", air = 0.01, cex = 1.0)
with (obs, ordisurf (spc_mds, SLPH, add = TRUE, col = "red" ))
with (obs, ordisurf (spc_mds, FDSP, add = TRUE, col = "green"))
#' ## Getting a `metaMDS` object from the species data
#' 
#' Calculating a `metaMDS` object on the `spc` data, for now without environmental
#' variables. Distance `jaccard` appears to be recommended in `vegan()`, 
#' `binary = TRUE` ensures correct distance calculation on presence / absence 
#' data. `try` is set higher, to look longer for solutions. Stress > 0.05 provides
#' an excellent representation in reduced dimensions, > 0.1 is great, > 0.2 is 
#' fair, and stress > 0.3 provides a poor representation. Inspect the generated 
#' model in the end. 
spc_mds <- metaMDS(spc, distance = "jaccard" ,  k = 2, try = 500, trymax = 1000, 
  noshare = FALSE, wascores = TRUE, trace = 0, plot = FALSE, expand = TRUE, 
  binary = FALSE)
spc_mds # stress value is 0.07224375
#' ### Fitting environmental vectors 
#' 
env <- envfit(spc_mds, obs, permutations = 5000)
env
par (mfrow = c (1, 1))
ordiplot (spc_mds, display = "sites" )
ordihull (spc_mds, groups  = shorten_groups (grp, obs) , 
   col = c ("coral3", "chartreuse4", "cornflowerblue") )
# ordiellipse(spc_mds, shorten_groups (grp, obs) , display = "sites", kind = "se", conf = 0.95, label = T, 
#   col = c ("coral3", "chartreuse4", "cornflowerblue"))
orditorp (spc_mds, display = "species", col="red", air = 0.01, cex = 1.0)
with (obs, ordisurf (spc_mds, SLPH, add = TRUE, col = "red" ))
with (obs, ordisurf (spc_mds, FDSP, add = TRUE, col = "green"))
#' 
#' Calculating a `metaMDS` object on the `spc` data, for now without environmental
#' variables. Distance `jaccard` appears to be recommended in `vegan()`, 
#' `binary = TRUE` ensures correct distance calculation on presence / absence 
#' data. `try` is set higher, to look longer for solutions. Stress > 0.05 provides
#' an excellent representation in reduced dimensions, > 0.1 is great, > 0.2 is 
#' fair, and stress > 0.3 provides a poor representation. Inspect the generated 
#' model in the end. 
spc_mds <- metaMDS(spc, distance = "euclid" ,  k = 2, try = 500, trymax = 1000, 
  noshare = FALSE, wascores = TRUE, trace = 0, plot = FALSE, expand = TRUE, 
  binary = FALSE)
spc_mds # stress value is 0.07224375
#' ### Fitting environmental vectors 
#' 
env <- envfit(spc_mds, obs, permutations = 5000)
env
par (mfrow = c (1, 1))
ordiplot (spc_mds, display = "sites" )
ordihull (spc_mds, groups  = shorten_groups (grp, obs) , 
   col = c ("coral3", "chartreuse4", "cornflowerblue") )
# ordiellipse(spc_mds, shorten_groups (grp, obs) , display = "sites", kind = "se", conf = 0.95, label = T, 
#   col = c ("coral3", "chartreuse4", "cornflowerblue"))
orditorp (spc_mds, display = "species", col="red", air = 0.01, cex = 1.0)
with (obs, ordisurf (spc_mds, SLPH, add = TRUE, col = "red" ))
with (obs, ordisurf (spc_mds, FDSP, add = TRUE, col = "green"))
obs
envfit(spc ~ obs$FDSP, data = obs, perm=1000)
envfit(spc ~ obs$FDSP, data = obs, perm=5000)
envfit(spc ~ obs, perm=5000)
obs
names$obs
names(obs)
envfit(spc ~ "AMMN" "NITR" "POTA" "SLPH" "PHOS" "CARB" "PHHO" "QUTZ" "FDSP" "PRAG"
[11] "MICA" "DOLO" "KAOC", data = obs, perm=5000)
envfit(spc ~ AMMN + NITR + POTA + SLPH + PHOS + CARB + PHHO + QUTZ + FDSP + 
  PRAG + MICA + DOLO + KAOC, data = obs, perm=5000)
envfit(spc ~ AMMN + NITR + POTA + SLPH + PHOS + CARB + PHHO + QUTZ + FDSP + 
  PRAG + MICA + DOLO + KAOC, data = obs, perm = 10000)
detach(obs)
detach(obs)
envfit(spc ~ AMMN + NITR + POTA + SLPH + PHOS + CARB + PHHO + QUTZ + FDSP + 
  PRAG + MICA + DOLO + KAOC, data = obs, perm = 10000)
spc
envfit(spc ~ AMMN + NITR + POTA + SLPH + PHOS + CARB + PHHO + QUTZ + FDSP + 
  PRAG + MICA + DOLO + KAOC, data = obs, perm = 10000)
envfit(spc ~ AMMN + NITR + POTA + SLPH + PHOS + CARB + PHHO + QUTZ + FDSP + 
  PRAG + MICA + DOLO + KAOC, data = obs, perm = 10000)
env <- envfit(spc_mds, obs, permutations = 5000)
env
envfit(spc ~ AMMN + NITR + POTA + SLPH + PHOS + CARB + PHHO + QUTZ + FDSP + 
  PRAG + MICA + DOLO + KAOC, data = obs, perm = 10000)
betad <- betadiver ( spc, "z")
betad
obs
adonis (formula =  betad, obs, perm = 10000)
betad
adonis (formula =  betad ~ AMMN + NITR + POTA + SLPH + PHOS + CARB + PHHO + QUTZ
  + FDSP + PRAG + MICA + DOLO + KAOC, data = obs, perm = 10000)
adonis (formula =  spc ~ AMMN + NITR + POTA + SLPH + PHOS + CARB + PHHO + QUTZ
  + FDSP + PRAG + MICA + DOLO + KAOC, data = obs, perm = 10000)
?betadiver()
envfit(spc ~ AMMN + NITR + POTA + SLPH + PHOS + CARB + PHHO + QUTZ + FDSP + 
  PRAG + MICA + DOLO + KAOC, data = obs, perm = 10000)
adonis (formula =  betadiver ( spc, "z") ~ AMMN + NITR + POTA + SLPH + PHOS + CARB + PHHO + QUTZ
  + FDSP + PRAG + MICA + DOLO + KAOC, data = obs, perm = 10000)
adonis (formula =  betadiver ( spc, "z") ~ AMMN * NITR * POTA * SLPH + PHOS + CARB + PHHO + QUTZ
  + FDSP + PRAG + MICA + DOLO + KAOC, data = obs, perm = 10000)
adonis (formula =  betadiver ( spc, "z") ~ AMMN * NITR * POTA * SLPH * PHOS * CARB * PHHO + QUTZ
  + FDSP + PRAG + MICA + DOLO + KAOC, data = obs, perm = 10)
adonis (formula =  betadiver ( spc, "z") ~ AMMN * NITR * POTA * SLPH * PHOS * CARB * PHHO + QUTZ
  * FDSP * PRAG * MICA * DOLO * KAOC, data = obs, perm = 10)
adonis (formula =  betadiver ( spc, "z") ~ AMMN * NITR * POTA * SLPH * PHOS * CARB * PHHO + QUTZ
  * FDSP * PRAG * MICA * DOLO * KAOC, data = obs, perm = 100)
adonis (formula =  betadiver ( spc, "z") ~ AMMN + NITR + POTA + SLPH + PHOS + 
  CARB + PHHO + QUTZ + FDSP + PRAG + MICA + DOLO + KAOC, data = obs, perm = 100)
envfit(spc ~ AMMN + NITR + POTA + SLPH + PHOS + CARB + PHHO + QUTZ + FDSP + 
  PRAG + MICA + DOLO + KAOC, data = obs, perm = 10000)
rmarkdown::render ("./50_eda.R")
rmarkdown::render ("./50_eda.R")
rmarkdown::render ("./50_eda.R")
git status
q()
